# УДАЛИТЬ: эта переменная используется только единожды — в её создании нет необходимости
binary_number = input('введите двоичное число: ')
prefix = {'b', '1', '0'}
# ПЕРЕИМЕНОВАТЬ: не нужно создавать дополнительных переменных, когда этого можно избежать — например здесь вместо создания новой переменной x вы можете использовать имя binary_number, так как значение, связанное ранее с этим именем, вам уже не требуется
x = list(binary_number)

is_prefix_chars = [{str(n)} < prefix for n in x]
# УДАЛИТЬ: цикл не используется
while True:
    # ИСПРАВИТЬ: для проверки всех элементов последовательности на истинность используйте встроенную функцию all()
    for i in range(len(x)):
        # ИСПРАВИТЬ: после ключевых слов if и elif интерпретатор ожидает объект bool, а не оператор сравнения — вам не нужно сравнивать объект bool с объектом False
        if is_prefix_chars[i-1] == False:
            print(f'\n{"нет"}\n')
            break
    if (
         # ИСПРАВИТЬ: число может состоять из одного символа (см. тест ниже)
            str(x[0]) == '0' and str(x[1]) == 'b'
         or str(x[0]) == 'b' and str(x[1]) != 'b'
         or str(x[0]) != '1' and str(x[1]) == 'b'
         or str(x[0]) != 'b' and str(x[1]) != 'b'
    ):
        print(f'\n{"да"}\n')
    else:
        print(f'\n{"нет"}\n')
    break

# СДЕЛАТЬ: перепишите код используя срезы и множества


# введите двоичное число: 0101
#
# да

# введите двоичное число: b11
#
# да

# введите двоичное число: 0b11001
#
# да

# введите двоичное число: 1b0101
#
# нет

# введите двоичное число: 1
# ...
# IndexError: list index out of range


# ИТОГ: переработать — 0/4
