# ИСПРАВИТЬ: если вы не собираетесь отдельно использовать str объект, то и не надо его сохранять — преобразовывайте сразу в int
n = input('')
bit_number = int('9' * int(n))
count_num = 0
# ИСПРАВИТЬ: цикл for здесь уместнее
x = int('1' + '0' * (int(n) - 1))
while x < bit_number:
    # ИСПРАВИТЬ: единица и само число всегда являются делителями, для них не нужно выполнять все проверки ниже — оптимизируйте
    n = 1
    # УДАЛИТЬ: если оптимально подберёте диапазон, то в данной переменной не будет необходимости
    check_num = 0
    while n <= x:
        if x % n == 0:
            check_num += 1
        # ИСПРАВИТЬ: в этом цикле ваша задача – выявить простое число, а не найти все делители — оптимизируйте условие
        # ИСПРАВИТЬ: приоритет операторов сравнения выше чем приоритет логических операторов — скобки избыточны
        if (n == x) and (check_num == 2):
            count_num += 1
            # ДОБАВИТЬ: break — выход из цикла
        n += 1
    x += 1
print(count_num)


# 3
# 143

# ДОБАВИТЬ: тесты с другими входными данными

# КОММЕНТАРИЙ: а если бы оптимизировали, то посчитали бы и до шести разрядов без длительного ожидания — а вам уже и на трёх разрядах поди ждать пришлось =) впрочем, решето Эратосфена, конечно, ещё быстрее даже сокращённого перебора


# ИТОГ: нужно лучше, переработать — 3/6
